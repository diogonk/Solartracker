#include "adc.h"
#include <stdint.h>
#include "tm4c1294ncpdt.h"

void ADC0_Init(void){
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R4; //ENABLE CLOCK IN PORT E
	SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R3; //ENABLE CLOCK IN PORT D
	while((SYSCTL_PRGPIO_R&SYSCTL_PRGPIO_R4) == 0){};
	while((SYSCTL_PRGPIO_R&SYSCTL_PRGPIO_R3) == 0){};
	GPIO_PORTE_AMSEL_R |= 0x0F;     //HABILITA FUNCAO ANALOGICA PE3-2-1-0
	GPIO_PORTE_PCTL_R  &= ~(0xFFFF);	
	GPIO_PORTE_DIR_R  &= ~(0x0F);
	
	GPIO_PORTD_AMSEL_R |= 0x03;     //HABILITA FUNCAO ANALOGICA PD1-0
	GPIO_PORTD_PCTL_R  &= ~(0xFF);	
	GPIO_PORTD_DIR_R  &= ~(0x03);

	GPIO_PORTE_AFSEL_R |= 0x0F;     //HABILITA FUNCAO ALTERNATIVA EM PE3-2-1-0
  GPIO_PORTE_DEN_R &= ~0x0F;      //DESABILITA I/O DIGITAL ANALOGICA PE3-2-1-0

	GPIO_PORTD_AFSEL_R |= 0x03;     //HABILITA FUNCAO ALTERNATIVA EM PD1-0
  GPIO_PORTD_DEN_R &= ~0x03;      //DESABILITA I/O DIGITAL ANALOGICA PD1-0

  	/*START ADC CONFIGURATION*/
											//ATIVA O CLOCK DE ADC0
	SYSCTL_RCGCADC_R |= SYSCTL_RCGCADC_R0;
											// ESPERA O BIT DE ADC INICIALIZADO
	while((SYSCTL_PRADC_R&SYSCTL_PRADC_R0) == 0){};
	ADC0_PC_R |= 0x07; 				//FULL CONVERSION RATE
	ADC0_SSPRI_R &= ~0x0123;	 	//SET SEQUENCERS PRIORITY
	ADC0_ACTSS_R &= ~(ADC_ACTSS_ASEN2+ADC_ACTSS_ASEN1); //DISABLE SEQUENCER TO CHANGE PARAMETERS
	ADC0_EMUX_R &= ~0x0FF0;			//
	
	/*SETA AS PORTAS ANALOGICAS
	SS2_0: AIN15(PD0)
	SS2_1: AIN14(PD1)
	*/
	ADC0_SSMUX2_R = ((ADC0_SSMUX2_R&~ADC_SSMUX2_MUX1_M)+(0xA<<ADC_SSMUX2_MUX1_S)) |
					((ADC0_SSMUX2_R&~ADC_SSMUX2_MUX0_M)+(0xB<<ADC_SSMUX2_MUX0_S));
	
	/*SETA AS PORTAS ANALOGICAS
	SS1_0: AIN0(PE3)
	SS1_1: AIN1(PE2)
	SS1_2: AIN2(PE1)
	SS1_3: AIN3(PE0)
	*/
	ADC0_SSMUX1_R = ((ADC0_SSMUX1_R&~ADC_SSMUX1_MUX3_M)+(0x3<<ADC_SSMUX1_MUX3_S)) | 
					((ADC0_SSMUX1_R&~ADC_SSMUX1_MUX2_M)+(0x2<<ADC_SSMUX1_MUX2_S)) |
					((ADC0_SSMUX1_R&~ADC_SSMUX1_MUX1_M)+(0x1<<ADC_SSMUX1_MUX1_S)) |
					((ADC0_SSMUX1_R&~ADC_SSMUX1_MUX0_M)+(0x0<<ADC_SSMUX1_MUX0_S));
	
	//ADC0_SSEMUX2_R &= ~0x0011; //AIN[15:0]
	//ADC0_SSEMUX1_R &= ~0x1111; //AIN[15:0]

	ADC0_SSCTL2_R = ((ADC0_SSCTL2_R&~0xFFFF)|0x60);		//SET LAST SAMPLE: END1
	ADC0_SSCTL1_R = ((ADC0_SSCTL1_R&~0xFFFF)|0x6000);	//SET LAST SAMPLE: END3
	
	ADC0_IM_R &= ~(ADC_IM_MASK2+ADC_IM_MASK1); 			//DISABLE INTERRUPT MASK

	ADC0_ACTSS_R |= (ADC_ACTSS_ASEN2+ADC_ACTSS_ASEN1);	//ENABLE SAMPLE SEQUENCER 2 AND 1

}


void ADC0_InSeq2(uint32_t data[2]){
  ADC0_PSSI_R |= 0x04;            // 1) initiate SS2
  while((ADC0_RIS_R&0x04) != 0x04){};   // 2) wait for conversion done
  data[1] = ADC0_SSFIFO2_R&0xFFF;  // 3A) read first result
  data[0] = ADC0_SSFIFO2_R&0xFFF;  // 3B) read second result
  ADC0_ISC_R = 0x0004;             // 4) acknowledge completion
}
void ADC0_InSeq1(uint32_t data[4]){
  ADC0_PSSI_R |= 0x02;            // 1) initiate SS1
  while((ADC0_RIS_R&0x02)!=0x02){};   // 2) wait for conversion done
  data[3] = ADC0_SSFIFO1_R&0xFFF;  // 3A) read first result
  data[2] = ADC0_SSFIFO1_R&0xFFF;  // 3B) read second result
  data[1] = ADC0_SSFIFO1_R&0xFFF;  // 3A) read third result
  data[0] = ADC0_SSFIFO1_R&0xFFF;  // 3B) read fourth result
  ADC0_ISC_R = 0x0002;             // 4) acknowledge completion
}
